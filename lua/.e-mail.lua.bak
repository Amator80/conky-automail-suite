------------------- KONFIGURACJA – TYLKO TUTAJ (wstęp + info) -------------------
--[[
#####################################################
#                                                   #
#               KONFIGURACJA – TYLKO TUTAJ           #
#   Tutaj ustawiasz wszystko pod siebie – możesz    #
#   zmieniać parametry czcionek, kolorów itd.      #
#   Każda opcja ma komentarz co ustawia.           #
#   Poniżej tej sekcji jest kod GŁÓWNY –            #
#   tam nie grzeb jeśli nie wiesz co robisz!       #
#                                                   #
#####################################################
]]

-- ====================================================================================
-- === GLOBALNY WSPÓŁCZYNNIK SKALOWANIA ===
-- Ustaw jedną wartość, aby powiększyć lub zmniejszyć wszystkie elementy.
-- Wartość mniejsza niż 1.0 (np. 0.8) -> zmniejsza widget.
-- Wartość większa niż 1.0 (np. 1.5) -> powiększa widget.
-- Domyślnie: 1.0 (oryginalny rozmiar).
GLOBAL_SCALE_FACTOR = 1.00
-- ====================================================================================

-- ŚCIEŻKI I OPCJE OGÓLNE
-- Skrypt Python uruchamiasz osobno w tle (np. przez crona lub bash loop)
-- Conky/Lua czyta TYLKO plik /tmp/conky-automail-suite/mail_cache.json generowany przez Pythona

------------------- GŁÓWNE USTAWIENIA WIDGETU -------------------

---------------------------------------ZUPIX FIX BLOK----------------------------------------------------------
---------------  PRZEWIJANIE LISTY MAILI - Globalne zmienne przewijania listy maili ------------
-- === SCROLLING MAILS ===
MAIL_SCROLL_FILE = "/tmp/conky-automail-suite/conky_mail_scroll_offset"
SCROLL_TIMEOUT   = 3.0  -- sekundy; po tym czasie od ostatniej modyfikacji offset wraca do 0 (zazwyczaj timeouty nie skalujemy, bo czas to czas)

--------------- LAYOUT - Globalne zmienne związane z działaniem layoutów -----------------------
LAYOUT_MODE = "down_left"                   -- TRYB LAYOUTU: wpisz jeden z trybów (do testów)
MAILS_DIRECTION = "up"                      -- rysowanie maili "down" = z góry na dół, "up" = z dołu do góry
SHOW_SENDER_EMAIL = false                   -- [true/false] Jeśli true, pokaże adres e-mail
SHOW_MAIL_PREVIEW = true                    -- [true/false] Jeśli true, pokaże fragment treści maila pod tematem
----------------------------------------------------------------------------------------------------------------

------------------- DŹWIĘKI (nowa/znikająca wiadomość) -------------------
NEW_MAIL_SOUND_ENABLE = true                                                     -- [true/false] Włącz dźwięk nowej wiadomości pocztowej
MAIL_DISAPPEAR_SOUND_ENABLE = true                                               -- [true/false] Dźwięk przy znikaniu maila z listy
NEW_MAIL_SOUND = "/home/linux/Pulpit/conky-automail-suite/sound/nowy_mail.wav"          -- Ścieżka do dźwięku nowej poczty (WAV)
MAIL_DISAPPEAR_SOUND = "/home/linux/Pulpit/conky-automail-suite/sound/remove_mail.wav"  -- Ścieżka do dźwięku znikającego maila z listy (WAV)

------------------- KOPERTA – IKONA GŁÓWNA -------------------
SHOW_ENVELOPE_ICON = true                                                        -- [true/false] Pokazuj ikonę koperty
ENVELOPE_IMAGE = "/home/linux/Pulpit/conky-automail-suite/icons/mail.png"               -- Ścieżka do obrazka koperty (PNG)

ENVELOPE_SIZE = { w = 141 * GLOBAL_SCALE_FACTOR, h = 141 * GLOBAL_SCALE_FACTOR } -- Rozmiar (szerokość, wysokość) koperty w px


------------------- USTAWIENIA LISTY MAILI (ilość, odstępy, zachowanie) -------------------
-- NOWE: źródło wartości dla badge
--  "unread"         -> globalne nieprzeczytane z całej skrzynki (data.unread)
--  "all"            -> wszystkie z całej skrzynki (data.all)
--  "unread_cache" -> ile NIEPRZECZYTANYCH faktycznie jest na liście po ograniczeniu N
--                     (Python: data.unread_cache)
BADGE_SOURCE = "unread"
MAX_MAILS = 5                                            -- Maksymalna liczba wyświetlanych maili na liście (nie skalujemy, to jest ilość)
MAIL_PREVIEW_LINES = 5                                   -- Ilość linii podglądu maila (0 = automatycznie) (nie skalujemy, to jest ilość)
PREVIEW_INDENT = false                                   -- [true/false] Czy podgląd ma być z wcięciem
MAIL_ROW_SPACING = 30 * GLOBAL_SCALE_FACTOR              -- Odstęp pionowy między mailami (px)
MAIL_PREVIEW_SPACING = 7.5 * GLOBAL_SCALE_FACTOR         -- Odstęp pionowy między tematem a podglądem maila (px)
META_LINE_SPACING = 7.5 * GLOBAL_SCALE_FACTOR            -- Odstęp pionowy między preview a meta-linią (px, czyli trzecia linia)
FROM_TO_SUBJECT_GAP = 12 * GLOBAL_SCALE_FACTOR           -- Odstęp poziomy między nadawcą a tematem (px)

------------------- MLECZNA POŚWIATA POD KAŻDYM MAILEM – KONFIGURACJA -------------------
-- Czy rysować poświatę pod każdym mailem?
PER_MAIL_MILK_FILL_ENABLE = true                         -- [true/false] Włącza wypełnienie „mlekiem” pod każdym mailem
PER_MAIL_MILK_FILL_COLOR = {255, 255, 255}               -- Kolor wypełnienia (RGB, np. biały, niebieski, czerwony)
PER_MAIL_MILK_FILL_ALPHA = 0.15                          -- Przezroczystość wypełnienia (0 = całkiem przezroczysty, 1 = pełny kolor)

-- Czy rysować ramkę (obramowanie) wokół „mleka”?
PER_MAIL_MILK_BORDER_ENABLE = false                      -- [true/false] Włącza ramkę wokół poświaty
PER_MAIL_MILK_BORDER_COLOR = {175, 238, 238}             -- Kolor ramki (RGB, np. niebieski, szary itd.)
PER_MAIL_MILK_BORDER_ALPHA = 0.25                        -- Przezroczystość ramki (0 = niewidoczna, 1 = pełny kolor)
PER_MAIL_MILK_BORDER_WIDTH = 4.5 * GLOBAL_SCALE_FACTOR   -- Grubość ramki w pikselach

-- Rozmiar i wygląd poświaty pod każdym mailem
PER_MAIL_MILK_RADIUS =  15 * GLOBAL_SCALE_FACTOR         -- Zaokrąglenie rogów poświaty oraz ramki (im więcej, tym bardziej „okrągłe” narożniki)
PER_MAIL_MILK_MARGIN_X = -30 * GLOBAL_SCALE_FACTOR       -- Dodatkowy margines na szerokość (ujemna wartość = większa poświata)
PER_MAIL_MILK_MARGIN_Y = -27 * GLOBAL_SCALE_FACTOR       -- Dodatkowy margines na wysokość (ujemna wartość = wyższa poświata)
PER_MAIL_MILK_WIDTH = 1102.5 * GLOBAL_SCALE_FACTOR       -- Szerokość poświaty (dopasuj do szerokości sekcji maili)
PER_MAIL_MILK_HEIGHT = 87 * GLOBAL_SCALE_FACTOR          -- Wysokość poświaty (dopasuj do wysokości pojedynczego bloku maila)

------------------- FORMATOWANIE "NADAWCA" (FROM) -------------------
FROM_FONT_NAME = "Arial"          -- Nazwa czcionki (np. Arial, Ubuntu, Noto Sans)
FROM_FONT_SIZE = 18 * GLOBAL_SCALE_FACTOR                -- Rozmiar czcionki nadawcy w px
FROM_FONT_BOLD = true                                    -- [true/false] Czy tekst nadawcy ma być pogrubiony?
FROM_FONT_ITALIC = false                                 -- [true/false] Czy tekst nadawcy ma być pochylony? (italic)
FROM_COLOR_TYPE = "custom"                               -- Kolor tekstu nadawcy: "white", "black" lub "custom"
FROM_COLOR_CUSTOM = {0.98, 0.145, 0.196}                 -- Jeśli powyżej "custom", to tu ustawiasz RGB (0-1 lub 0-255)
FROM_MAX_WIDTH = 400 * GLOBAL_SCALE_FACTOR               -- **Maksymalna szerokość pola nadawcy w pikselach** (jeśli tekst za długi, może się przewijać)

-- PRZEWIJANIE NADAWCY (dla długich nazw, np. korporacyjnych adresów)
FROM_SCROLL_ENABLE = true                                -- [true/false] Czy przewijać nadawcę jeśli się nie mieści w polu?
FROM_SCROLL_SPEED = 37.5 * GLOBAL_SCALE_FACTOR           -- Prędkość przewijania w px/s (im wyższa, tym szybciej)
FROM_SCROLL_REPEAT = 2                                   -- Ile razy przewinąć nadawcę (potem się zatrzyma)
FROM_SCROLL_DELAY = 1                                    -- Opóźnienie startu przewijania (s) (zazwyczaj timeouty nie skalujemy)
FROM_SCROLL_EASE = "easeOut"                             -- Styl przewijania: "easeOut" (wolniejsze końcówki), "linear" (stałe tempo)
FROM_SCROLL_EXTRA = 0 * GLOBAL_SCALE_FACTOR              -- Dodatkowy "bufor" na końcu przewijania (px)

------------------- FORMATOWANIE "TEMAT" (SUBJECT) -------------------
SUBJECT_FONT_NAME = "Arial"         -- Czcionka tematu
SUBJECT_FONT_SIZE = 18 * GLOBAL_SCALE_FACTOR             -- Rozmiar czcionki tematu
SUBJECT_FONT_BOLD = true                                 -- [true/false] Czy temat ma być pogrubiony?
SUBJECT_FONT_ITALIC = false                              -- [true/false] Czy temat ma być pochylony?
SUBJECT_COLOR_TYPE = "white"                             -- Kolor tematu: "white", "black", "custom"
SUBJECT_COLOR_CUSTOM = {0.424, 1, 0}                     -- Własny kolor RGB tematu (gdy powyżej "custom")
SUBJECT_MAX_WIDTH = 1065 * GLOBAL_SCALE_FACTOR           -- **Maksymalna szerokość pola tematu w px**

-- PRZEWIJANIE TEMATU (Subject)
SUBJECT_SCROLL_ENABLE = true                             -- [true/false] Czy przewijać temat jeśli się nie mieści?
SUBJECT_SCROLL_SPEED = 37.5 * GLOBAL_SCALE_FACTOR        -- Prędkość przewijania tematu (px/s)
SUBJECT_SCROLL_REPEAT = 2                                -- Ile razy przewinąć temat
SUBJECT_SCROLL_DELAY = 1                                 -- Opóźnienie startu przewijania (s) (zazwyczaj timeouty nie skalujemy)
SUBJECT_SCROLL_EASE = "easeOut"                          -- Styl przewijania: "easeOut" (płynnie), "linear" (stałe tempo)
SUBJECT_SCROLL_EXTRA = 36 * GLOBAL_SCALE_FACTOR          -- Dodatkowy bufor na końcu przewijania (px)

------------------- FORMATOWANIE "TREŚĆ PODGLĄDU" (PREVIEW) -------------------
PREVIEW_FONT_NAME = "Arial"                              -- Czcionka podglądu (preview)
PREVIEW_FONT_SIZE = 16.5 * GLOBAL_SCALE_FACTOR           -- Rozmiar czcionki podglądu
PREVIEW_FONT_BOLD = true                                 -- [true/false] Czy tekst preview ma być pogrubiony?
PREVIEW_FONT_ITALIC = false                              -- [true/false] Czy tekst preview ma być pochylony?
PREVIEW_COLOR_TYPE = "custom"                            -- Kolor preview: "white", "black", "custom"
PREVIEW_COLOR_CUSTOM = {22, 217, 197}                    -- Własny kolor RGB (jeśli wybrałeś "custom")
PREVIEW_MAX_WIDTH = 1065 * GLOBAL_SCALE_FACTOR           -- **Maksymalna szerokość pola preview w px**

-- PRZEWIJANIE PREVIEW
PREVIEW_SCROLL_ENABLE = true                             -- [true/false] Czy przewijać podgląd jeśli za długi?
PREVIEW_SCROLL_SPEED = 67.5 * GLOBAL_SCALE_FACTOR        -- Prędkość przewijania preview (px/s)
PREVIEW_SCROLL_REPEAT = 2                                -- Ile razy przewinąć podgląd (preview)
PREVIEW_SCROLL_DELAY = 1                                 -- Opóźnienie startu przewijania (s) (zazwyczaj timeouty nie skalujemy)
PREVIEW_SCROLL_EASE = "easeOut"                          -- Styl przewijania: "easeOut", "linear"
PREVIEW_SCROLL_EXTRA = 36 * GLOBAL_SCALE_FACTOR          -- Bufor przewijania na końcu (px)

------------------- BADGE (KÓŁKO Z LICZBĄ NIEPRZECZYTANYCH) -------------------
BADGE_COLOR_TYPE = "red"                                 -- Kolor środka badge: "red", "white", "black", "custom"
BADGE_COLOR_CUSTOM = {22, 217, 197}                      -- Własny kolor RGB środka (jeśli powyżej "custom")
BADGE_TEXT_COLOR_TYPE = "white"                          -- Kolor cyfry (liczby maili) na badge
BADGE_TEXT_COLOR_CUSTOM = {255, 255, 0}                  -- Własny kolor cyfry (gdy "custom")
BADGE_BORDER_COLOR_TYPE = "white"                        -- Kolor obwódki badge
BADGE_BORDER_COLOR_CUSTOM = {0, 255, 0}                  -- Własny kolor obwódki (gdy "custom")
SHOW_BADGE = true                                        -- [true/false] Pokazuj kółko z liczbą maili (badge)

------------------- KROPKA LUB IKONA ZAŁĄCZNIKA PRZY MAILU -------------------
ATTACHMENT_DOT_ENABLE = false                            -- [true/false] Czy wyświetlać kropkę przy nadawcy, jeśli mail ma załącznik?
ATTACHMENT_DOT_COLOR_TYPE = "orange"                     -- Kolor kropki: "orange", "white", "black", "custom"
ATTACHMENT_DOT_COLOR_CUSTOM = {255, 140, 0}              -- Własny kolor kropki (jeśli "custom")
ATTACHMENT_DOT_RADIUS = 7.5 * GLOBAL_SCALE_FACTOR        -- Promień kropki (px)
ATTACHMENT_DOT_OFFSET = { dx = -15 * GLOBAL_SCALE_FACTOR, dy = -15 * GLOBAL_SCALE_FACTOR }  -- Przesunięcie kropki względem nadawcy (x, y)

ATTACHMENT_ICON_ENABLE = true                            -- [true/false] Czy wyświetlać ikonę zamiast kropki?
ATTACHMENT_ICON_SIZE = { w = 36 * GLOBAL_SCALE_FACTOR, h = 42 * GLOBAL_SCALE_FACTOR }        -- Rozmiar ikony (szerokość, wysokość)
ATTACHMENT_ICON_OFFSET = { dx = -33 * GLOBAL_SCALE_FACTOR, dy = -15 * GLOBAL_SCALE_FACTOR }  -- Przesunięcie ikony względem nadawcy (x, y)
ATTACHMENT_ICON_ANGLE = 0                     -- Obrót ikony (w stopniach)
ATTACHMENT_ICON_MIRROR = false                -- [true/false] Lustrzane odbicie ikony
ATTACHMENT_ICON_IMAGE = "/home/linux/Pulpit/conky-automail-suite/icons/spinacz1.png" -- Ścieżka do ikony (np. spinacz)

------------------- WŁASNY NAGŁÓWEK/NOTKA -------------------
CUSTOM_TEXT_ENABLE = true                     -- [true/false] Czy wyświetlać własny tekst?
CUSTOM_TEXT_VALUE = "Mail@Desk Twój osobisty asystent poczty" -- Twój tekst nagłówka
CUSTOM_TEXT_FONT = "Arial"                    -- Czcionka tekstu
CUSTOM_TEXT_SIZE = 27 * GLOBAL_SCALE_FACTOR   -- Rozmiar tekstu
CUSTOM_TEXT_BOLD = true                       -- [true/false] Pogrubienie tekstu?
CUSTOM_TEXT_ITALIC = false                    -- [true/false] Pochylenie tekstu?
CUSTOM_TEXT_COLOR_TYPE = "custom"             -- Kolor: "white", "black", "custom"
CUSTOM_TEXT_COLOR_CUSTOM = {255, 60, 0}       -- Własny kolor RGB tekstu (jeśli custom)

------------------- SEPARATOR (LINIA OZDOBNA MIĘDZY NAGŁÓWKIEM A MAJLAMI) -------------------
SEPARATOR_ENABLE = true                       -- [true/false] Czy wyświetlać linię oddzielającą?
SEPARATOR_LENGTH = 550 * GLOBAL_SCALE_FACTOR  -- Długość linii w px
SEPARATOR_COLOR_TYPE = "white"                -- Kolor linii: "white", "black", "custom"
SEPARATOR_COLOR_CUSTOM = {150, 150, 150}      -- Własny kolor RGB (gdy "custom")
SEPARATOR_WIDTH = 3 * GLOBAL_SCALE_FACTOR     -- Grubość linii (px)

------------------- 3 LINIA META (POD MAILEM – DANE TECHNICZNE, GODZINA, IP itp.) -------------------
META_LINE_ENABLE = true   -- [true/false] Czy pokazywać trzecią linię pod każdym mailem (meta-info)
META_LINE_ORDER = {       -- Tutaj ustawiasz w jakiej kolejności będą wyświetlane informacje w meta-linii:
    "age_text",   -- ile temu (np. "2h temu")
    "hour",       -- godzina odebrania maila
    "date",       -- data odebrania maila
    "ip",         -- IP z prefixem IP:
    "ip_city",    -- miasto
    "isp",        -- operator
    "agent",      -- user-agent (np. Thunderbird)
    "country",    -- kraj
    "mobile",     -- czy wysłany z mobilnego
}
META_SHOW_IP = true         -- [true/false] Czy pokazywać IP (jeśli nie operator mobilny)
META_SHOW_IP_CITY = true    -- [true/false] Czy pokazywać miasto (jeśli nie operator mobilny)
META_SHOW_IP_ISP = true     -- [true/false] Czy pokazywać nazwę operatora internetu (ISP)
META_SHOW_AGE_TEXT = true   -- [true/false] Czy pokazywać "wiek" maila ("2h temu" itd.)
META_SHOW_DATETIME = true   -- [true/false] Czy pokazywać datę/godzinę odebrania maila
META_SHOW_AGENT = true      -- [true/false] Czy pokazywać User-Agent (np. Thunderbird, Gmail)
META_SHOW_COUNTRY = true    -- [true/false] Czy pokazywać kraj nadawcy
META_SHOW_MOBILE = true     -- [true/false] Czy pokazywać "MOBILNY" jeśli mail wysłany przez sieć mobilną
META_LINE_MAX_WIDTH = 1050 * GLOBAL_SCALE_FACTOR    -- **Maksymalna szerokość meta-linii w px**
META_LINE_SCROLL_ENABLE = true    -- [true/false] Czy przewijać meta-linię, jeśli za długa
META_LINE_SCROLL_SPEED = 37.5 * GLOBAL_SCALE_FACTOR   -- Prędkość przewijania (px/s)
META_LINE_SCROLL_REPEAT = 2       -- Ile razy przewinąć meta-linię
META_LINE_SCROLL_DELAY = 1        -- Opóźnienie startu przewijania (sekundy) (zazwyczaj timeouty nie skalujemy)
META_LINE_SCROLL_EASE = "easeOut" -- Styl przewijania: "easeOut" lub "linear"
META_LINE_SCROLL_EXTRA = 36 * GLOBAL_SCALE_FACTOR       -- Bufor przewijania na końcu (px)

-- Kolory poszczególnych informacji w meta-linii (podaj w formacie 0-1, np. 1 = 255)
META_COLOR_IP = {144, 182, 238}         -- Kolor IP
META_COLOR_CITY = {144, 182, 238}       -- Kolor miasta
META_COLOR_ISP = {144, 182, 238}        -- Kolor operatora
META_COLOR_AGE = {144, 182, 238}        -- Kolor "wiek maila"
META_COLOR_DATETIME = {144, 182, 238}   -- Kolor daty/godziny
META_COLOR_AGENT = {144, 182, 238}      -- Kolor User-Agent
META_COLOR_COUNTRY = {144, 182, 238}    -- Kolor kraju
META_COLOR_MOBILE = {144, 182, 238}     -- Kolor napisu MOBILNY
META_COLOR_SEPARATOR = {134, 255, 0}    -- kolor RGB separatora (separator między polami w meta-linii)

META_LINE_FONT_NAME = "Arial"         -- Czcionka meta-linii
META_LINE_FONT_SIZE = 16.5 * GLOBAL_SCALE_FACTOR      -- Rozmiar czcionki meta-linii
META_LINE_FONT_BOLD = true          -- [true/false] Pogrubienie meta-linii
META_LINE_FONT_ITALIC = false         -- [true/false] Pochylenie meta-linii

META_DATE_FORMAT = "HH:MM DD-MM-YYYY" -- Format daty/godziny (do wyboru kilku typów)
META_DATE_FORMAT_CUSTOM = "%H:%M:%S %d.%m.%Y"    -- Twój własny format, jeśli wybrałeś "custom"

------------------------------------------------------------------------------------------
-- *** KONIEC KONFIGURACJI. PONIŻEJ JEST KOD GŁÓWNY – NIE RUSZAĆ! ***
------------------------------------------------------------------------------------------

-- Ustawienie ścieżki, aby Lua znalazła lokalny plik dkjson.lua
local script_path = debug.getinfo(1, "S").source:match("@(.*/)")
package.path = package.path .. ";" .. script_path .. "?.lua"

require 'cairo'
CAIRO_FORMAT_ARGB32 = 0
pcall(require, 'cairo_xlib')
local json = require("dkjson")

-----------------(Zupix FIX)-------------------
-- BLOK LAYOUTÓW – pełna kontrola pozycji     --
-----------------------------------------------

ENVELOPE_CORR  = { x = 0, y = 0 }
MAILS_CORR     = { x = 0, y = 0 }
SEPARATOR_CORR = { x = 0, y = 0 }
TEXT_CORR      = { x = 0, y = 0 }

ENVELOPE_POS    = { x = 0, y = 0 }
MAILS_POS       = { x = 0, y = 0 }
CUSTOM_TEXT_POS = { x = 0, y = 0 }
SEPARATOR_X     = 0
SEPARATOR_Y     = 0

-- Pomocnicze stałe bazowe (możesz zmienić pod swój gust)
local BASE_LEFT   = 45 * GLOBAL_SCALE_FACTOR      -- baza od lewej krawędzi
local BASE_RIGHT  = 60 * GLOBAL_SCALE_FACTOR      -- baza od prawej krawędzi
local BASE_TOP    = 37.5 * GLOBAL_SCALE_FACTOR    -- baza od górnej krawędzi
local BASE_BOTTOM = 37.5 * GLOBAL_SCALE_FACTOR    -- baza od dolnej krawędzi

-- Wysokości separacji między elementami (nagłówek/separator/mail-list/envelope)
local GAP_HEADER_TO_SEP   = 57 * GLOBAL_SCALE_FACTOR  -- Odstęp między nagłówkiem a separatorem (linią)
local GAP_SEP_TO_MAILS    = 27 * GLOBAL_SCALE_FACTOR  -- Odstęp między separatorem a listą maili
local GAP_MAILS_TO_ENV    = 18 * GLOBAL_SCALE_FACTOR  -- ile px między ostatnią linią a kopertą (gdy envelope pod listą)

-- Dla trybów up/down lista od góry/dół (Twoja logika kierunku jest dalej w kodzie)
-- Tu ustawiamy tylko punkt referencyjny MAILS_POS i od niego liczymy resztę.

-- ============ UP (wyśrodkowany, koperta po prawej końcówce bloku) ============
function set_layout_up()
    -- LOKALNE KOREKTORY
    MAILS_DIRECTION = "down"                                                        -- Kierunek rysowania listy maili (z góry na dół)
    ENVELOPE_MIRROR = true                                                          -- [true/false] Lustrzane odbicie ikony koperty
    ENVELOPE_IMAGE_ANGLE = 0                                                        -- Obrót koperty w stopniach
    BADGE_RADIUS = 22.5 * GLOBAL_SCALE_FACTOR                                       -- Promień kółka z liczbą nieprzeczytanych maili
    BADGE_POS = { dx = 15.5 * GLOBAL_SCALE_FACTOR, dy = 7.5 * GLOBAL_SCALE_FACTOR } -- Przesunięcie badge'a (kółka) względem koperty (oś X, oś Y)
    local ENV_X, ENV_Y = 126 * GLOBAL_SCALE_FACTOR, -35 * GLOBAL_SCALE_FACTOR       -- Korekta pozycji dla ikony koperty (oś X, oś Y)
    local MAIL_X, MAIL_Y = -37.5 * GLOBAL_SCALE_FACTOR, -45 * GLOBAL_SCALE_FACTOR   -- Korekta pozycji dla całej listy maili (oś X, oś Y)
    local SEP_X, SEP_Y = 520.5 * GLOBAL_SCALE_FACTOR, -55.5 * GLOBAL_SCALE_FACTOR   -- Korekta pozycji dla separatora (linii) (oś X, oś Y)
    local TXT_X, TXT_Y = -28 * GLOBAL_SCALE_FACTOR, 2 * GLOBAL_SCALE_FACTOR         -- Korekta pozycji dla własnego tekstu/nagłówka (oś X, oś Y)

    -- MAILS (środek poziomy, od góry)
    MAILS_POS.x = (conky_window.width - (PER_MAIL_MILK_WIDTH or (1080 * GLOBAL_SCALE_FACTOR))) / 2 + MAILS_CORR.x + MAIL_X
    MAILS_POS.y = BASE_TOP + GAP_HEADER_TO_SEP + GAP_SEP_TO_MAILS + MAILS_CORR.y + MAIL_Y

    -- SEPARATOR (pod nagłówkiem, wyśrodkowany względem MAILS_POS.x)
    SEPARATOR_X = MAILS_POS.x + SEPARATOR_CORR.x + SEP_X
    SEPARATOR_Y = BASE_TOP + GAP_HEADER_TO_SEP + SEPARATOR_CORR.y + SEP_Y

    -- CUSTOM HEADER (nad separatorem)
    CUSTOM_TEXT_POS.x = MAILS_POS.x + TEXT_CORR.x + TXT_X
    CUSTOM_TEXT_POS.y = BASE_TOP + TEXT_CORR.y + TXT_Y

    -- ENVELOPE (po prawej końcówce bloku mailowego)
    ENVELOPE_POS.x = MAILS_POS.x + (PER_MAIL_MILK_WIDTH or (1080 * GLOBAL_SCALE_FACTOR)) - ENVELOPE_SIZE.w + ENVELOPE_CORR.x + ENV_X
    ENVELOPE_POS.y = SEPARATOR_Y + GAP_SEP_TO_MAILS + ENVELOPE_CORR.y + ENV_Y
end


-- ============ DOWN (wyśrodkowany, koperta po prawej końcówce bloku) ============
function set_layout_down()
    -- LOKALNE KOREKTORY
    MAILS_DIRECTION = "up"                                                           -- Kierunek rysowania listy maili (z góry na dół)
    ENVELOPE_MIRROR = true                                                           -- [true/false] Lustrzane odbicie ikony koperty
    ENVELOPE_IMAGE_ANGLE = 0                                                         -- Obrót koperty w stopniach
    BADGE_RADIUS = 22.5 * GLOBAL_SCALE_FACTOR                                        -- Promień kółka z liczbą nieprzeczytanych maili
    BADGE_POS = { dx = 15 * GLOBAL_SCALE_FACTOR, dy = 7.5 * GLOBAL_SCALE_FACTOR }    -- Przesunięcie badge'a (kółka) względem koperty (oś X, oś Y)
    local ENV_X, ENV_Y = 132 * GLOBAL_SCALE_FACTOR, 30 * GLOBAL_SCALE_FACTOR         -- Korekta pozycji dla ikony koperty (oś X, oś Y)
    local MAIL_X, MAIL_Y = -45 * GLOBAL_SCALE_FACTOR, -52.5 * GLOBAL_SCALE_FACTOR    -- Korekta pozycji dla całej listy maili (oś X, oś Y)
    local SEP_X, SEP_Y = 521.5 * GLOBAL_SCALE_FACTOR, 206.5 * GLOBAL_SCALE_FACTOR    -- Korekta pozycji dla separatora (linii) (oś X, oś Y)
    local TXT_X, TXT_Y = -27 * GLOBAL_SCALE_FACTOR, 47.5 * GLOBAL_SCALE_FACTOR       -- Korekta pozycji dla własnego tekstu/nagłówka (oś X, oś Y)

    -- MAILS (środek poziomy, od dołu)
    MAILS_POS.x = (conky_window.width - (PER_MAIL_MILK_WIDTH or (1080 * GLOBAL_SCALE_FACTOR))) / 2 + MAILS_CORR.x + MAIL_X
    MAILS_POS.y = BASE_BOTTOM + GAP_MAILS_TO_ENV + MAILS_CORR.y + MAIL_Y

    -- SEPARATOR (nad kopertą lub nad mailami)
    SEPARATOR_X = MAILS_POS.x + SEPARATOR_CORR.x + SEP_X
    SEPARATOR_Y = conky_window.height - BASE_BOTTOM - GAP_MAILS_TO_ENV - ENVELOPE_SIZE.h - (18 * GLOBAL_SCALE_FACTOR) + SEPARATOR_CORR.y + SEP_Y

    -- CUSTOM HEADER (nad separatorem)
    CUSTOM_TEXT_POS.x = MAILS_POS.x + TEXT_CORR.x + TXT_X
    CUSTOM_TEXT_POS.y = SEPARATOR_Y - (GAP_HEADER_TO_SEP - (9 * GLOBAL_SCALE_FACTOR)) + TEXT_CORR.y + TXT_Y

    -- ENVELOPE (po prawej końcówce bloku mailowego)
    ENVELOPE_POS.x = MAILS_POS.x + (PER_MAIL_MILK_WIDTH or (1080 * GLOBAL_SCALE_FACTOR)) - ENVELOPE_SIZE.w + ENVELOPE_CORR.x + ENV_X
    ENVELOPE_POS.y = conky_window.height - BASE_BOTTOM - ENVELOPE_SIZE.h + ENVELOPE_CORR.y + ENV_Y
end


-- ============ UP_LEFT (góra-lewo; koperta po prawej końcówce bloku) ============
function set_layout_up_left()
    -- LOKALNE KOREKTORY
    MAILS_DIRECTION = "down"                                                          -- Kierunek rysowania listy maili (z góry na dół)
    ENVELOPE_MIRROR = true                                                            -- [true/false] Lustrzane odbicie ikony koperty
    ENVELOPE_IMAGE_ANGLE = 0                                                          -- Obrót koperty w stopniach
    BADGE_RADIUS = 22.5 * GLOBAL_SCALE_FACTOR                                         -- Promień kółka z liczbą nieprzeczytanych maili
    BADGE_POS = { dx = 15.5 * GLOBAL_SCALE_FACTOR, dy = 7.5 * GLOBAL_SCALE_FACTOR }   -- Przesunięcie badge'a (kółka) względem koperty (oś X, oś Y)
    local ENV_X, ENV_Y = 135 * GLOBAL_SCALE_FACTOR, -22.5 * GLOBAL_SCALE_FACTOR       -- Korekta pozycji dla ikony koperty (oś X, oś Y)
    local MAIL_X, MAIL_Y = 0 * GLOBAL_SCALE_FACTOR, -52.5 * GLOBAL_SCALE_FACTOR       -- Korekta pozycji dla całej listy maili (oś X, oś Y)
    local SEP_X, SEP_Y = 520.5 * GLOBAL_SCALE_FACTOR, -60.5 * GLOBAL_SCALE_FACTOR     -- Korekta pozycji dla separatora (linii) (oś X, oś Y)
    local TXT_X, TXT_Y = -27 * GLOBAL_SCALE_FACTOR, -5 * GLOBAL_SCALE_FACTOR          -- Korekta pozycji dla własnego tekstu/nagłówka (oś X, oś Y)

    MAILS_POS.x = BASE_LEFT + MAILS_CORR.x + MAIL_X
    MAILS_POS.y = BASE_TOP + GAP_HEADER_TO_SEP + GAP_SEP_TO_MAILS + MAILS_CORR.y + MAIL_Y

    SEPARATOR_X = MAILS_POS.x + SEPARATOR_CORR.x + SEP_X
    SEPARATOR_Y = BASE_TOP + GAP_HEADER_TO_SEP + SEPARATOR_CORR.y + SEP_Y

    CUSTOM_TEXT_POS.x = MAILS_POS.x + TEXT_CORR.x + TXT_X
    CUSTOM_TEXT_POS.y = BASE_TOP + TEXT_CORR.y + TXT_Y

    ENVELOPE_POS.x = MAILS_POS.x + (PER_MAIL_MILK_WIDTH or (1080 * GLOBAL_SCALE_FACTOR)) - ENVELOPE_SIZE.w + ENVELOPE_CORR.x + ENV_X
    ENVELOPE_POS.y = SEPARATOR_Y + GAP_SEP_TO_MAILS + ENVELOPE_CORR.y + ENV_Y
end

-- ============ UP_RIGHT (góra-prawo; koperta po LEWEJ stronie bloku) ============
function set_layout_up_right()
    -- LOKALNE KOREKTORY
    MAILS_DIRECTION = "down"                                                           -- Kierunek rysowania listy maili (z góry na dół)
    ENVELOPE_MIRROR = false                                                            -- [true/false] Lustrzane odbicie ikony koperty
    ENVELOPE_IMAGE_ANGLE = 0                                                           -- Obrót koperty w stopniach
    BADGE_RADIUS = 22.5 * GLOBAL_SCALE_FACTOR                                          -- Promień kółka z liczbą nieprzeczytanych maili
    BADGE_POS = { dx = 120.5 * GLOBAL_SCALE_FACTOR, dy = 7.5 * GLOBAL_SCALE_FACTOR }   -- Przesunięcie badge'a (kółka) względem koperty (oś X, oś Y)
    local ENV_X, ENV_Y = -180 * GLOBAL_SCALE_FACTOR, -31 * GLOBAL_SCALE_FACTOR         -- Korekta pozycji dla ikony koperty (oś X, oś Y)
    local MAIL_X, MAIL_Y = 75 * GLOBAL_SCALE_FACTOR, -52.5 * GLOBAL_SCALE_FACTOR       -- Korekta pozycji dla całej listy maili (oś X, oś Y)
    local SEP_X, SEP_Y = 522.5 * GLOBAL_SCALE_FACTOR, -60.5 * GLOBAL_SCALE_FACTOR      -- Korekta pozycji dla separatora (linii) (oś X, oś Y)
    local TXT_X, TXT_Y = -27 * GLOBAL_SCALE_FACTOR, -1.5 * GLOBAL_SCALE_FACTOR         -- Korekta pozycji dla własnego tekstu/nagłówka (oś X, oś Y)

    -- MAILS przyklejone do prawej krawędzi okna
    MAILS_POS.x = conky_window.width - (PER_MAIL_MILK_WIDTH or (1080 * GLOBAL_SCALE_FACTOR)) - BASE_RIGHT + MAILS_CORR.x + MAIL_X
    MAILS_POS.y = BASE_TOP + GAP_HEADER_TO_SEP + GAP_SEP_TO_MAILS + MAILS_CORR.y + MAIL_Y

    SEPARATOR_X = MAILS_POS.x + SEPARATOR_CORR.x + SEP_X
    SEPARATOR_Y = BASE_TOP + GAP_HEADER_TO_SEP + SEPARATOR_CORR.y + SEP_Y

    CUSTOM_TEXT_POS.x = MAILS_POS.x + TEXT_CORR.x + TXT_X
    CUSTOM_TEXT_POS.y = BASE_TOP + TEXT_CORR.y + TXT_Y

    -- koperta po LEWEJ stronie bloku (początek)
    ENVELOPE_POS.x = MAILS_POS.x + ENVELOPE_CORR.x + ENV_X
    ENVELOPE_POS.y = SEPARATOR_Y + GAP_SEP_TO_MAILS + ENVELOPE_CORR.y + ENV_Y
end

-- ============ DOWN_LEFT (dół-lewo; koperta po prawej końcówce bloku) ============
function set_layout_down_left()
    -- LOKALNE KOREKTORY
    MAILS_DIRECTION = "up"                                                          -- Kierunek rysowania listy maili (z góry na dół)
    ENVELOPE_MIRROR = true                                                          -- [true/false] Lustrzane odbicie ikony koperty
    ENVELOPE_IMAGE_ANGLE = 0                                                        -- Obrót koperty w stopniach
    BADGE_RADIUS = 22.5 * GLOBAL_SCALE_FACTOR                                       -- Promień kółka z liczbą nieprzeczytanych maili
    BADGE_POS = { dx = 15 * GLOBAL_SCALE_FACTOR, dy = 7.5 * GLOBAL_SCALE_FACTOR }   -- Przesunięcie badge'a (kółka) względem koperty (oś X, oś Y)
    local ENV_X, ENV_Y = 135 * GLOBAL_SCALE_FACTOR, 30 * GLOBAL_SCALE_FACTOR        -- Korekta pozycji dla ikony koperty (oś X, oś Y)
    local MAIL_X, MAIL_Y = 0 * GLOBAL_SCALE_FACTOR, -52.5 * GLOBAL_SCALE_FACTOR     -- Korekta pozycji dla całej listy maili (oś X, oś Y)
    local SEP_X, SEP_Y = 521.5 * GLOBAL_SCALE_FACTOR, 206.5 * GLOBAL_SCALE_FACTOR   -- Korekta pozycji dla separatora (linii) (oś X, oś Y)
    local TXT_X, TXT_Y = -27 * GLOBAL_SCALE_FACTOR, 47.5 * GLOBAL_SCALE_FACTOR      -- Korekta pozycji dla własnego tekstu/nagłówka (oś X, oś Y)

    MAILS_POS.x = BASE_LEFT + MAILS_CORR.x + MAIL_X
    MAILS_POS.y = BASE_BOTTOM + GAP_MAILS_TO_ENV + MAILS_CORR.y + MAIL_Y

    SEPARATOR_X = MAILS_POS.x + SEPARATOR_CORR.x + SEP_X
    SEPARATOR_Y = conky_window.height - BASE_BOTTOM - GAP_MAILS_TO_ENV - ENVELOPE_SIZE.h - (18 * GLOBAL_SCALE_FACTOR) + SEPARATOR_CORR.y + SEP_Y

    CUSTOM_TEXT_POS.x = MAILS_POS.x + TEXT_CORR.x + TXT_X
    CUSTOM_TEXT_POS.y = SEPARATOR_Y -  (GAP_HEADER_TO_SEP - (9 * GLOBAL_SCALE_FACTOR)) + TEXT_CORR.y + TXT_Y

    -- ENVELOPE (po prawej końcówce bloku mailowego)
    ENVELOPE_POS.x = MAILS_POS.x + (PER_MAIL_MILK_WIDTH or (1080 * GLOBAL_SCALE_FACTOR)) - ENVELOPE_SIZE.w + ENVELOPE_CORR.x + ENV_X
    ENVELOPE_POS.y = conky_window.height - BASE_BOTTOM - ENVELOPE_SIZE.h + ENVELOPE_CORR.y + ENV_Y
end

-- ============ DOWN_RIGHT (dół-prawo; koperta po LEWEJ stronie bloku) ============
function set_layout_down_right()
    -- LOKALNE KOREKTORY
    MAILS_DIRECTION = "up"                                                             -- Kierunek rysowania listy maili (z góry na dół)
    ENVELOPE_MIRROR = false                                                            -- [true/false] Lustrzane odbicie ikony koperty
    ENVELOPE_IMAGE_ANGLE = 0                                                           -- Obrót koperty w stopniach
    BADGE_RADIUS = 22.5 * GLOBAL_SCALE_FACTOR                                          -- Promień kółka z liczbą nieprzeczytanych maili
    BADGE_POS = { dx = 123.5 * GLOBAL_SCALE_FACTOR, dy = 7.5 * GLOBAL_SCALE_FACTOR }   -- Przesunięcie badge'a (kółka) względem koperty (oś X, oś Y)
    local ENV_X, ENV_Y = -185 * GLOBAL_SCALE_FACTOR , 30.5 * GLOBAL_SCALE_FACTOR       -- Korekta pozycji dla ikony koperty (oś X, oś Y)
    local MAIL_X, MAIL_Y = 75 * GLOBAL_SCALE_FACTOR, -52.5 * GLOBAL_SCALE_FACTOR       -- Korekta pozycji dla całej listy maili (oś X, oś Y)
    local SEP_X, SEP_Y = 525.5 * GLOBAL_SCALE_FACTOR, 205.5 * GLOBAL_SCALE_FACTOR      -- Korekta pozycji dla separatora (linii) (oś X, oś Y)
    local TXT_X, TXT_Y = -27 * GLOBAL_SCALE_FACTOR, 48.5 * GLOBAL_SCALE_FACTOR         -- Korekta pozycji dla własnego tekstu/nagłówka (oś X, oś Y)

    MAILS_POS.x = conky_window.width - (PER_MAIL_MILK_WIDTH or (1080 * GLOBAL_SCALE_FACTOR)) - BASE_RIGHT + MAILS_CORR.x + MAIL_X
    MAILS_POS.y = BASE_BOTTOM + GAP_MAILS_TO_ENV + MAILS_CORR.y + MAIL_Y

    SEPARATOR_X = MAILS_POS.x + SEPARATOR_CORR.x + SEP_X
    SEPARATOR_Y = conky_window.height - BASE_BOTTOM - GAP_MAILS_TO_ENV - ENVELOPE_SIZE.h - (18 * GLOBAL_SCALE_FACTOR) + SEPARATOR_CORR.y + SEP_Y

    CUSTOM_TEXT_POS.x = MAILS_POS.x + TEXT_CORR.x + TXT_X
    CUSTOM_TEXT_POS.y = SEPARATOR_Y -  (GAP_HEADER_TO_SEP - (9 * GLOBAL_SCALE_FACTOR)) + TEXT_CORR.y + TXT_Y

    -- koperta po LEWEJ stronie bloku (początek)
    ENVELOPE_POS.x = MAILS_POS.x + ENVELOPE_CORR.x + ENV_X
    ENVELOPE_POS.y = conky_window.height - BASE_BOTTOM - ENVELOPE_SIZE.h + ENVELOPE_CORR.y + ENV_Y
end

-- ============ Router trybu ============
function set_layout_by_mode()
    if      LAYOUT_MODE == "up"         then set_layout_up()
    elseif LAYOUT_MODE == "down"       then set_layout_down()
    elseif LAYOUT_MODE == "up_left"   then set_layout_up_left()
    elseif LAYOUT_MODE == "up_right"  then set_layout_up_right()
    elseif LAYOUT_MODE == "down_left" then set_layout_down_left()
    elseif LAYOUT_MODE == "down_right" then set_layout_down_right()
    else
        set_layout_down_left() -- domyślnie
    end
end


local function utf8_sub(s, i, j)
    local pos = 1
    local bytes = #s
    local start, end_ = nil, nil
    local k = 0
    while pos <= bytes do
        k = k + 1
        if k == i then start = pos end
        if k == (j and j + 1 or nil) then end_ = pos - 1 break end
        local c = s:byte(pos)
        if c < 0x80 then pos = pos + 1
        elseif c < 0xE0 then pos = pos + 2
        elseif c < 0xF0 then pos = pos + 3
        else pos = pos + 4 end
    end
    if start then return s:sub(start, end_ or bytes) end
    return ""
end

local function utf8_len(s)
    local _, count = s:gsub("[^\128-\193]", "")
    return count
end

local function safe_str(s, fallback)
    if s == nil then return fallback or "" end
    if type(s) == "string" then return s end
    return tostring(s)
end

local function set_font(cr, font_name, font_size, bold, italic)
    cairo_select_font_face(
        cr,
        font_name,
        italic and CAIRO_FONT_SLANT_ITALIC or CAIRO_FONT_SLANT_NORMAL,
        bold and CAIRO_FONT_WEIGHT_BOLD or CAIRO_FONT_WEIGHT_NORMAL
    )
    cairo_set_font_size(cr, font_size)
end

local function split_emoji(text)
    local res = {}
    local pattern = "[\xF0-\xF7][\x80-\xBF][\x80-\xBF][\x80-\xBF]"
    local last_end = 1
    for start_pos, end_pos in function() return text:find(pattern, last_end) end do
        if start_pos > last_end then
            table.insert(res, {emoji=false, txt=text:sub(last_end, start_pos-1)})
        end
        table.insert(res, {emoji=true, txt=text:sub(start_pos, end_pos)})
        last_end = end_pos + 1
    end
    if last_end <= #text then
        table.insert(res, {emoji=false, txt=text:sub(last_end)})
    end
    return res
end

-- Liczenie szerokości tekstu z emoji
local function text_width_with_emoji(cr, text, font_name, font_size, font_bold, font_italic)
    local width = 0
    local emoji_chunks = split_emoji(text)
    for idx, chunk in ipairs(emoji_chunks) do
        if chunk.emoji then
            cairo_select_font_face(cr, "Noto Color Emoji", CAIRO_FONT_SLANT_NORMAL, font_bold and CAIRO_FONT_WEIGHT_BOLD or CAIRO_FONT_WEIGHT_NORMAL)
        else
            cairo_select_font_face(cr, font_name, font_italic and CAIRO_FONT_SLANT_ITALIC or CAIRO_FONT_SLANT_NORMAL, font_bold and CAIRO_FONT_WEIGHT_BOLD or CAIRO_FONT_WEIGHT_NORMAL)
        end
        cairo_set_font_size(cr, font_size)
        local ext2 = cairo_text_extents_t:create()
        cairo_text_extents(cr, chunk.txt, ext2)
        width = width + ext2.x_advance
    end
    return width
end

-- Obcinanie tekstu z emoji do max_width
local function trim_line_to_width_emoji(cr, text, max_width, font_name, font_size, font_bold, font_italic)
    local ellipsis = "..."
    local trimmed = ""
    for i = 1, utf8_len(text) do
        local chunk = utf8_sub(text, 1, i)
        local w = text_width_with_emoji(cr, chunk .. ellipsis, font_name, font_size, font_bold, font_italic)
        if w > max_width then
            break
        end
        trimmed = chunk
    end
    -- Jeśli tekst się mieści, zwróć całość:
    if text_width_with_emoji(cr, text, font_name, font_size, font_bold, font_italic) <= max_width then
        return text
    end
    return trimmed .. ellipsis
end


-- Sprawdź, czy to pierwszy start po reboocie (nie ma pliku last_seen)
local function file_exists(path)
    local ok, f = pcall(io.open, path, "r")
    if ok and f then f:close(); return true end
    return false
end
local FIRST_RUN = not file_exists("/tmp/conky-automail-suite/last_seen_mails.json")

-- ===============================================
-- Wczytywanie listy UID ostatnio wyświetlonych maili (do przewijania)
-- ===============================================
local last_seen_uids = {}

local function load_last_seen_uids()
    local f = io.open("/tmp/conky-automail-suite/last_seen_mails.json", "r")
    if not f then return {} end
    local content = f:read("*a")
    f:close()
    local ok, uids = pcall(function() return json.decode(content) end)
    if ok and type(uids) == "table" then
        local set = {}
        for _, uid in ipairs(uids) do set[uid] = true end
        return set
    end
    return {}
end

-- Załaduj UID-y na starcie Conky
last_seen_uids = load_last_seen_uids()

-- ===============================================
-- Pomocnicza funkcja: czy mail jest NOWY (nie był widziany)
-- ===============================================
local function is_new_mail(mail)
    if FIRST_RUN then return true end
    local uid = mail.uid or ((mail.subject or "") .. (mail.from or ""))
    return not last_seen_uids[uid]
end

-- CACHE PNG: Ładuje obrazek tylko raz i trzyma w pamięci
local png_cache = {}
local function get_png_surface(path)
    if not png_cache[path] then
        local surface = cairo_image_surface_create_from_png(path)
        if cairo_surface_status(surface) ~= 0 then
            print("BŁĄD: Nie można załadować pliku PNG: " .. tostring(path))
            surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 1, 1)
        end
        png_cache[path] = surface
    end
    return png_cache[path]
end

local previous_unread_count = nil
local last_good_mails = {}
local last_mail_json_ok = false

local scroll_states = {
    subject = {},
    preview = {},
}
local from_scroll_states = {}
local meta_scroll_states = {}

-- [PATCH] Cache’y: szerokości, cięcia tekstu, preview i meta szerokości
local width_cache = {}
local trim_cache  = {}
local meta_width_cache = {}

local function cache_key_width(text, font, size, bold, italic)
    return table.concat({text or "", font or "", size or 0, bold and "b" or "n", italic and "i" or "n"}, "|")
end

local function cached_text_width_emoji(cr, text, font, size, bold, italic)
    local k = cache_key_width(text, font, size, bold, italic)
    local w = width_cache[k]
    if w then return w end
    w = text_width_with_emoji(cr, text or "", font, size, bold, italic)
    width_cache[k] = w
    return w
end

local function cached_trim_emoji(cr, text, maxw, font, size, bold, italic)
    local k = table.concat({text or "", maxw or 0, font or "", size or 0, bold and "b" or "n", italic and "i" or "n"}, "|")
    local v = trim_cache[k]
    if v then return v end
    v = trim_line_to_width_emoji(cr, text or "", maxw, font, size, bold, italic)
    trim_cache[k] = v
    return v
end
-- [/PATCH]

local function fetch_mails_from_cache()
    local CACHE_FILE = "/tmp/conky-automail-suite/mail_cache.json"
    local f = io.open(CACHE_FILE, "r")
    if not f then
        print("Nie znaleziono pliku cache!")
        last_mail_json_ok = false
        return {}
    end
    local result = f:read("*a")
    f:close()
    local data, pos, err = json.decode(result, 1, nil)
if not data or type(data) ~= "table" then
    print("Błąd dekodowania JSON z pliku cache:", err)
    last_mail_json_ok = false
    return {}
end
if type(data.mails) ~= "table" then data.mails = {} end
last_mail_json_ok = true
return data
end
local function save_max_mails_to_file()
    local count_file = "/home/linux/Pulpit/conky-automail-suite/config/mail_count.conf"
    local f = io.open(count_file, "w")
    if f then
        f:write(MAX_MAILS, "\n")
        f:close()
    end
end
save_max_mails_to_file()

local function save_preview_lines_to_file()
    local preview_file = "/home/linux/Pulpit/conky-automail-suite-newPY2/config/mail_preview_lines.conf"
    local f = io.open(preview_file, "w")
    if f then
        f:write(MAIL_PREVIEW_LINES, "\n")
        f:close()
    end
end
save_preview_lines_to_file()

-- POPRAWKA: użycie cache dla PNG
local function draw_png_rotated(cr, x, y, w, h, path, angle_deg, mirror_x)
    local image = get_png_surface(path)
    local img_w = cairo_image_surface_get_width(image)
    local img_h = cairo_image_surface_get_height(image)
    cairo_save(cr)
    cairo_translate(cr, x + w/2, y + h/2)
    cairo_rotate(cr, math.rad(angle_deg or 0))
    if mirror_x then
        cairo_scale(cr, -w / img_w, h / img_h)
        cairo_translate(cr, -img_w / 2, -img_h / 2)
    else
        cairo_scale(cr, w / img_w, h / img_h)
        cairo_translate(cr, -img_w / 2, -img_h / 2)
    end
    cairo_set_source_surface(cr, image, 0, 0)
    cairo_paint(cr)
    cairo_restore(cr)
    -- NIE niszczymy surface, bo cache!
end

local function get_mail_id(mail)
    local subj = tostring(mail.subject or ""):sub(1,64)
    local from = tostring(mail.from or ""):sub(1,32)
    local preview = tostring(mail.preview or ""):sub(1,32)
    return subj .. "|" .. from .. "|" .. preview
end

local function trim_line_to_width(cr, text, max_width)
    local ellipsis = "..."
    local ext_ellipsis = cairo_text_extents_t:create()
    cairo_text_extents(cr, ellipsis, ext_ellipsis)
    local ellipsis_width = ext_ellipsis.width

    local trimmed = text
    local total_width = 0
    local last_good = ""

    for i = 1, utf8_len(text) do
        local chunk = utf8_sub(text, 1, i)
        local ext = cairo_text_extents_t:create()
        cairo_text_extents(cr, chunk .. ellipsis, ext)
        if ext.width > max_width then
            break
        end
        last_good = chunk
    end

    local ext_full = cairo_text_extents_t:create()
    cairo_text_extents(cr, text, ext_full)
    if ext_full.width <= max_width then
        return text
    end

    return last_good .. ellipsis
end

-- DEKODER BEZPIECZNYCH WARTOŚCI RGB
local function decode_rgb(val)
    val = tonumber(val) or 0
    if val ~= val then return 0 end -- NaN
    if val < 0 then return 0 end
    if val > 255 then return 1 end
    if val <= 1 then return val end
    return val / 255
end

local function decode_rgb3(rgb)
    if type(rgb) ~= "table" then return 0, 0, 0 end
    return decode_rgb(rgb[1]), decode_rgb(rgb[2]), decode_rgb(rgb[3])
end

-- BEZPIECZNY CLAMP DO ZAKRESU 0..1 (np. dla przezroczystości)
local function clamp01(a)
    a = tonumber(a) or 0
    if a < 0 then return 0 end
    if a > 1 then return 1 end
    return a
end

local function set_color(cr, typ, custom)
    if typ == "white" then
        cairo_set_source_rgb(cr, 1, 1, 1)
    elseif typ == "black" then
        cairo_set_source_rgb(cr, 0, 0, 0)
    elseif typ == "red" then
        cairo_set_source_rgb(cr, 1, 0, 0)
    elseif typ == "orange" then
        cairo_set_source_rgb(cr, 1, 0.55, 0)
    elseif typ == "custom" and custom then
    local r, g, b = decode_rgb3(custom)
    cairo_set_source_rgb(cr, r, g, b)
    else
        cairo_set_source_rgb(cr, 1, 1, 1)
    end
end

local function draw_emoji_text(cr, text, font_name, font_bold, font_size, x, y, font_italic)
    if not text or text == "" then return 0 end
    local cursor = x
    local emoji_chunks = split_emoji(text)
    for idx, chunk in ipairs(emoji_chunks) do
        cairo_move_to(cr, cursor, y)
        if chunk.emoji then
            cairo_select_font_face(cr, "Noto Color Emoji", CAIRO_FONT_SLANT_NORMAL, font_bold and CAIRO_FONT_WEIGHT_BOLD or CAIRO_FONT_WEIGHT_NORMAL)
        else
            cairo_select_font_face(cr, font_name, font_italic and CAIRO_FONT_SLANT_ITALIC or CAIRO_FONT_SLANT_NORMAL, font_bold and CAIRO_FONT_WEIGHT_BOLD or CAIRO_FONT_WEIGHT_NORMAL)
        end
        cairo_set_font_size(cr, font_size)
        cairo_show_text(cr, chunk.txt)
        local ext2 = cairo_text_extents_t:create()
        cairo_text_extents(cr, chunk.txt, ext2)
        cursor = cursor + ext2.x_advance
    end
    return cursor - x
end

local function ease_out(t)
    return 1 - (1 - t) * (1 - t)
end

local function join_preview_lines(preview_txt, max_lines)
    if not preview_txt or preview_txt == "" then return "" end
    local lines = {}
    for line in preview_txt:gmatch("[^\r\n]+") do
        line = line:gsub("^%s+", ""):gsub("%s+$", "")
        if line ~= "" then
            table.insert(lines, line)
        end
        if max_lines and max_lines > 0 and #lines >= max_lines then break end
    end
    if #lines == 0 then return preview_txt end
    return table.concat(lines, " ")
end

local function get_mail_from_id(mail, from_txt)
    local from_base = tostring(mail.from or "") .. "|" .. tostring(mail.from_name or "")
    local subject = tostring(mail.subject or "")
    return from_base:sub(1,64) .. "|" .. subject:sub(1,64) .. "|" .. (from_txt or "")
end

print("[diag] conky_parse:", type(_G.conky_parse))
-- w okolicach definicji now_time() wstaw zamiast starej:
local _tick_counter = 0
local function now_time()
    local dt = (type(_G.conky_info) == "table" and tonumber(_G.conky_info.update_interval)) or 1
    if type(_G.conky_parse) == "function" then
        local ok, updates = pcall(_G.conky_parse, "${updates}")
        local upd = tonumber(ok and updates or 0) or 0
        return upd * dt
    else
        _tick_counter = _tick_counter + 1
        return _tick_counter * dt
    end
end

-- ==================================================================================
-- POCZĄTEK MODYFIKACJI: Nowa funkcja do rysowania nadawcy z kolorowym aliasem
-- ==================================================================================
local function draw_colored_sender(cr, mail, text_to_draw, x, y)
    -- Ustawienia czcionki są już ustawione przez funkcję wywołującą
    local font_name = FROM_FONT_NAME
    local font_size = FROM_FONT_SIZE
    local font_bold = FROM_FONT_BOLD
    local font_italic = FROM_FONT_ITALIC

    local alias_prefix = ""
    local sender_part = text_to_draw
    local has_color_alias = false

    -- Sprawdź, czy mail ma alias i przypisany kolor
    if mail.account_name and mail.account_name ~= "" and mail.color and type(mail.color) == "table" then
        local prefix_candidate = "[" .. mail.account_name .. "] "
        -- Sprawdź, czy tekst do narysowania faktycznie zaczyna się od tego aliasu
        if text_to_draw:sub(1, #prefix_candidate) == prefix_candidate then
            alias_prefix = prefix_candidate
            sender_part = text_to_draw:sub(#prefix_candidate + 1)
            has_color_alias = true
        end
    end

    if has_color_alias then
        -- 1. Narysuj alias z jego specyficznym kolorem
        local a = (mail.color[1] or 255) / 255
        local r = (mail.color[2] or 255) / 255
        local g = (mail.color[3] or 255) / 255
        local b = (mail.color[4] or 255) / 255
        cairo_set_source_rgba(cr, r, g, b, a)
        local alias_width = draw_emoji_text(cr, alias_prefix, font_name, font_bold, font_size, x, y, font_italic)

        -- 2. Narysuj resztę tekstu nadawcy z domyślnym kolorem
        set_color(cr, FROM_COLOR_TYPE, FROM_COLOR_CUSTOM)
        draw_emoji_text(cr, sender_part, font_name, font_bold, font_size, x + alias_width, y, font_italic)
    else
        -- Jeśli nie ma aliasu lub koloru, narysuj cały tekst normalnie, z domyślnym kolorem
        set_color(cr, FROM_COLOR_TYPE, FROM_COLOR_CUSTOM)
        draw_emoji_text(cr, text_to_draw, font_name, font_bold, font_size, x, y, font_italic)
    end
end
-- ==================================================================================
-- KONIEC MODYFIKACJI
-- ==================================================================================


-- ##################################################################################
-- ### POCZĄTEK ZMODYFIKOWANEGO BLOKU ###
-- ##################################################################################
local function draw_from_scrolling(cr, mail, from_txt, x, y)
    -- Pobranie parametrów z konfiguracji globalnej
    local maxw = FROM_MAX_WIDTH
    local scroll_enable = FROM_SCROLL_ENABLE and is_new_mail(mail)
    local scroll_speed  = FROM_SCROLL_SPEED
    local scroll_repeat = FROM_SCROLL_REPEAT
    local scroll_delay  = FROM_SCROLL_DELAY
    local scroll_ease   = FROM_SCROLL_EASE
    local scroll_extra  = FROM_SCROLL_EXTRA
    local font_name     = FROM_FONT_NAME
    local font_bold     = FROM_FONT_BOLD
    local font_size     = FROM_FONT_SIZE
    local font_italic   = FROM_FONT_ITALIC

    -- Ustawienie czcionki do obliczeń szerokości
    set_font(cr, font_name, font_size, font_bold, font_italic)

    -- Obliczenie całkowitej szerokości tekstu nadawcy
    local total_width = text_width_with_emoji(cr, from_txt, font_name, font_size, font_bold, font_italic)

    -- --- PRZYPADEK 1: Tekst się mieści lub przewijanie jest wyłączone ---
    if total_width <= maxw or not scroll_enable then
        local trimmed_text = trim_line_to_width_emoji(cr, from_txt, maxw, font_name, font_size, font_bold, font_italic)
        -- Używamy funkcji pomocniczej, która już prawidłowo obsługuje kolory
        draw_colored_sender(cr, mail, trimmed_text, x, y)
        local final_width = text_width_with_emoji(cr, trimmed_text, font_name, font_size, font_bold, font_italic)
        return x + final_width
    end

    -- --- PRZYPADEK 2: Tekst jest za długi i wymaga przewijania ---
    
    -- Pobranie/inicjalizacja stanu przewijania
    local mail_id = get_mail_from_id(mail, from_txt)
    local now = now_time()
    local state = from_scroll_states[mail_id]
    if not state or state.last_mail_id ~= mail_id then
        from_scroll_states[mail_id] = {start_time=now, phase="start", rep=0, last_mail_id=mail_id}
        state = from_scroll_states[mail_id]
    end

    -- Podział tekstu na statyczny alias i przewijaną część
    local alias_prefix = ""
    local sender_part = from_txt
    local has_alias = false

    if mail.account_name and mail.account_name ~= "" then
        local prefix_candidate = "[" .. mail.account_name .. "] "
        if from_txt:sub(1, #prefix_candidate) == prefix_candidate then
            alias_prefix = prefix_candidate
            sender_part = from_txt:sub(#prefix_candidate + 1)
            has_alias = true
        end
    end

    -- Obliczenie szerokości poszczególnych części
    local alias_width = 0
    if has_alias then
        alias_width = text_width_with_emoji(cr, alias_prefix, font_name, font_size, font_bold, font_italic)
    end
    local sender_width = text_width_with_emoji(cr, sender_part, font_name, font_size, font_bold, font_italic)

    -- Zdefiniowanie obszaru rysowania dla części przewijanej
    local sender_x = x + alias_width
    local sender_max_w = maxw - alias_width
    if sender_max_w < 0 then sender_max_w = 0 end -- Zabezpieczenie

    -- Obliczenie parametrów animacji przewijania
    local scroll_len = sender_width - sender_max_w + scroll_extra
    if scroll_len < 1 then scroll_len = 1 end
    
    local delay_start  = scroll_delay or 0
    local pause_end    = 1.0
    local scroll_time  = math.max(scroll_len / (scroll_speed or (72 * GLOBAL_SCALE_FACTOR)), 0.5)
    local elapsed = now - state.start_time
    local phase = state.phase
    local ease_func = scroll_ease or "linear"

    -- --- Logika Rysowania ---

    -- 1. Narysuj statyczny alias (jeśli istnieje)
    if has_alias then
        -- Ta część jest statyczna i rysowana poza jakimkolwiek obszarem przycinania
        local a = (mail.color[1] or 255) / 255
        local r = (mail.color[2] or 255) / 255
        local g = (mail.color[3] or 255) / 255
        local b = (mail.color[4] or 255) / 255
        cairo_set_source_rgba(cr, r, g, b, a)
        draw_emoji_text(cr, alias_prefix, font_name, font_bold, font_size, x, y, font_italic)
    end

    -- Ustawienie koloru dla części nadawcy
    set_color(cr, FROM_COLOR_TYPE, FROM_COLOR_CUSTOM)
    
    -- 2. Narysuj przewijaną część nadawcy w zależności od aktualnej fazy animacji
    if phase == "start" then
        if elapsed < delay_start then
            -- Przed rozpoczęciem przewijania, pokaż przycięty tekst
            local trimmed_sender = trim_line_to_width_emoji(cr, sender_part, sender_max_w, font_name, font_size, font_bold, font_italic)
            draw_emoji_text(cr, trimmed_sender, font_name, font_bold, font_size, sender_x, y, font_italic)
        else
            -- Czas rozpocząć przewijanie
            state.phase = "scroll"
            state.start_time = now
            -- Aby uniknąć migotania na 1 klatkę, narysuj pierwszą klatkę przewijania
            cairo_save(cr)
            cairo_rectangle(cr, sender_x, y - font_size, sender_max_w, font_size + (12 * GLOBAL_SCALE_FACTOR))
            cairo_clip(cr)
            draw_emoji_text(cr, sender_part, font_name, font_bold, font_size, sender_x, y, font_italic)
            cairo_restore(cr)
        end

    elseif phase == "scroll" then
        local t = math.min(1, elapsed / scroll_time)
        local ease_t = (ease_func == "easeOut") and ease_out(t) or t
        local offset = ease_t * scroll_len
        
        cairo_save(cr)
        cairo_rectangle(cr, sender_x, y - font_size, sender_max_w, font_size + (12 * GLOBAL_SCALE_FACTOR))
        cairo_clip(cr)
        draw_emoji_text(cr, sender_part, font_name, font_bold, font_size, sender_x - offset, y, font_italic)
        cairo_restore(cr)
        
        if t >= 1 then
            state.phase = "pause_end"
            state.start_time = now
        end
        
    elseif phase == "pause_end" then
        if elapsed < pause_end then
            -- Przytrzymaj tekst na końcu przewijania
            cairo_save(cr)
            cairo_rectangle(cr, sender_x, y - font_size, sender_max_w, font_size + (12 * GLOBAL_SCALE_FACTOR))
            cairo_clip(cr)
            draw_emoji_text(cr, sender_part, font_name, font_bold, font_size, sender_x - scroll_len, y, font_italic)
            cairo_restore(cr)
        else
            -- Sprawdź, czy powtórzyć, czy zakończyć
            state.rep = state.rep + 1
            if state.rep < scroll_repeat then
                state.phase = "start"
                state.start_time = now
            else
                state.phase = "done"
            end
        end
        
    elseif phase == "done" then
        -- Przewijanie zakończone, ponownie pokaż przycięty tekst
        local trimmed_sender = trim_line_to_width_emoji(cr, sender_part, sender_max_w, font_name, font_size, font_bold, font_italic)
        draw_emoji_text(cr, trimmed_sender, font_name, font_bold, font_size, sender_x, y, font_italic)
    end
    
    -- Zwróć maksymalną szerokość pola, aby temat wyrównał się poprawnie
    return x + maxw
end
-- ##################################################################################
-- ### KONIEC ZMODYFIKOWANEGO BLOKU ###
-- ##################################################################################


local function draw_scrolling_text(cr, key, mail, text, x, y, maxw, font_name, font_size, font_bold, font_italic, opt)
    if not text or text == "" then return end
    local state_table = scroll_states[key] or {}
    scroll_states[key] = state_table
    local get_id = function()
        return key .. "|" .. get_mail_id(mail) .. "|" .. (text or "")
    end
    local mail_id = get_id()
    local now = now_time()
    local state = state_table[mail_id]
    if not state or state.last_mail_id ~= mail_id then
        state_table[mail_id] = {start_time=now, phase="start", rep=0, last_mail_id=mail_id}
        state = state_table[mail_id]
    end

    set_font(cr, font_name, font_size, font_bold, font_italic)
    local text_width = cached_text_width_emoji(cr, text, font_name, font_size, font_bold, font_italic)

if text_width <= maxw or not opt.scroll_enable then
    local trimmed = cached_trim_emoji(cr, text, maxw, font_name, font_size, font_bold, font_italic)
    draw_emoji_text(cr, trimmed, font_name, font_bold, font_size, x, y, font_italic)
    return
end

    local scroll_extra = opt.scroll_extra or (36 * GLOBAL_SCALE_FACTOR)
    local scroll_len = text_width - maxw + scroll_extra
    if scroll_len < 1 then scroll_len = 1 end
    local delay_start  = opt.scroll_delay or 0
    local pause_end    = 1.0
    local scroll_speed = opt.scroll_speed or (72 * GLOBAL_SCALE_FACTOR)
    local scroll_repeat = opt.scroll_repeat or 2
    local scroll_time  = math.max(scroll_len / scroll_speed, 0.5)
    local elapsed = now - state.start_time
    local phase = state.phase
    local ease_func = opt.scroll_ease or "linear"

    if phase == "start" then
        if elapsed < delay_start then
            local trimmed = cached_trim_emoji(cr, text, maxw, font_name, font_size, font_bold, font_italic)
            draw_emoji_text(cr, trimmed, font_name, font_bold, font_size, x, y, font_italic)
        else
            state.phase = "scroll"
            state.start_time = now
        end

    elseif phase == "scroll" then
        local t = math.min(1, elapsed / scroll_time)
        local ease_t = (ease_func == "easeOut") and ease_out(t) or t
        local offset = ease_t * scroll_len

        cairo_save(cr)
        cairo_rectangle(cr, x, y - font_size, maxw, font_size + (12 * GLOBAL_SCALE_FACTOR))
        cairo_clip(cr)
        draw_emoji_text(cr, text, font_name, font_bold, font_size, x - offset, y, font_italic)
        cairo_restore(cr)

        if t >= 1 then
            state.phase = "pause_end"
            state.start_time = now
        end

    elseif phase == "pause_end" then
        if elapsed < pause_end then
            cairo_save(cr)
            cairo_rectangle(cr, x, y - font_size, maxw, font_size + (12 * GLOBAL_SCALE_FACTOR))
            cairo_clip(cr)
            draw_emoji_text(cr, text, font_name, font_bold, font_size, x - scroll_len, y, font_italic)
            cairo_restore(cr)
        else
            state.rep = state.rep + 1
            if state.rep < scroll_repeat then
                state.phase = "start"
                state.start_time = now
            else
                state.phase = "done"
            end
        end

    elseif phase == "done" then
    local trimmed = cached_trim_emoji(cr, text, maxw, font_name, font_size, font_bold, font_italic)
    draw_emoji_text(cr, trimmed, font_name, font_bold, font_size, x, y, font_italic)
    end
end

-- ======================================
-- DODANE: Funkcja do rysowania mlecznej poświaty pod każdym mailem
-- ======================================
local function draw_per_mail_milk(
    cr, x, y, w, h, radius,
    fill_enable, fill_color, fill_alpha,
    border_enable, border_color, border_alpha, border_width
)
    cairo_save(cr)
    cairo_new_path(cr)
    cairo_move_to(cr, x + radius, y)
    cairo_arc(cr, x + w - radius, y + radius, radius, -math.pi/2, 0)
    cairo_arc(cr, x + w - radius, y + h - radius, radius, 0, math.pi/2)
    cairo_arc(cr, x + radius, y + h - radius, radius, math.pi/2, math.pi)
    cairo_arc(cr, x + radius, y + radius, radius, math.pi, 1.5*math.pi)
    cairo_close_path(cr)

    if fill_enable then
        local r, g, b = decode_rgb3(fill_color)
        cairo_set_source_rgba(cr, r, g, b, clamp01(fill_alpha or 0.2))
        cairo_fill_preserve(cr)
    end

    if border_enable then
        local br, bg, bb = decode_rgb3(border_color)
        cairo_set_source_rgba(cr, br, bg, bb, clamp01(border_alpha or 0.2))
        cairo_set_line_width(cr, border_width or (3 * GLOBAL_SCALE_FACTOR))
        cairo_stroke(cr)
    else
        cairo_new_path(cr)
    end
    cairo_restore(cr)
end

-- ======================================
-- KONIEC DODATKU Z MLEKIEM
-- ======================================

-- ========== NOWA META-LINIA “RICH TEXT” ==========

local function build_meta_line_segments(mail)
    if not mail or not mail.meta then return {} end
    local m = mail.meta
    local segments = {}
    local first = true

    local function add_separator()
        if not first then
            table.insert(segments, {txt=" | ", color=META_COLOR_SEPARATOR})
        end
    end

    for _, field in ipairs(META_LINE_ORDER) do
        local val, color = nil, nil
        if field == "age_text" and META_SHOW_AGE_TEXT and m.age_text and m.age_text ~= "" then
            val, color = m.age_text, META_COLOR_AGE
        elseif field == "hour" and META_SHOW_DATETIME and m.datetime and m.datetime ~= "" then
            local year, month, day, hour, min, sec = m.datetime:match("(%d+)%-(%d+)%-(%d+) (%d+):(%d+):(%d+)")
            if hour and min and sec then
                val, color = string.format("%02d:%02d:%02d", tonumber(hour), tonumber(min), tonumber(sec)), META_COLOR_DATETIME
            end
        elseif field == "date" and META_SHOW_DATETIME and m.datetime and m.datetime ~= "" then
            local year, month, day, hour, min, sec = m.datetime:match("(%d+)%-(%d+)%-(%d+) (%d+):(%d+):(%d+)")
            if year and month and day then
                val, color = string.format("%02d-%02d-%04d", tonumber(day), tonumber(month), tonumber(year)), META_COLOR_DATETIME
            end
        elseif field == "ip" and META_SHOW_IP and m.ip and m.ip ~= "" and (not m.mobile or not META_SHOW_MOBILE) then
            val, color = "IP:"..m.ip, META_COLOR_IP
        elseif field == "ip_city" and META_SHOW_IP_CITY and m.ip_city and m.ip_city ~= "" and (not m.mobile or not META_SHOW_MOBILE) then
            val, color = m.ip_city, META_COLOR_CITY
        elseif field == "isp" and META_SHOW_IP_ISP and m.isp and m.isp ~= "" and (not m.mobile or not META_SHOW_MOBILE) then
            val, color = m.isp, META_COLOR_ISP
        elseif field == "agent" and META_SHOW_AGENT and m.agent and m.agent ~= "" then
            val, color = m.agent, META_COLOR_AGENT
        elseif field == "country" and META_SHOW_COUNTRY and m.country and m.country ~= "" then
            val, color = m.country, META_COLOR_COUNTRY
        elseif field == "mobile" and META_SHOW_MOBILE and m.mobile then
            val, color = "MOBILNY", META_COLOR_MOBILE
        end
        if val then
            add_separator()
            table.insert(segments, {txt=val, color=color})
            first = false
        end
    end
    return segments
end

local function measure_meta_line_width(cr, segments, font_name, font_bold, font_size, font_italic)
    local width = 0
    for _, seg in ipairs(segments) do
        set_font(cr, font_name, font_size, font_bold, font_italic)
        local ext = cairo_text_extents_t:create()
        cairo_text_extents(cr, seg.txt, ext)
        width = width + ext.x_advance
    end
    return width
end

local function draw_meta_segments_trimmed(cr, segments, font_name, font_bold, font_size, font_italic, x, y, max_width)
    local cursor = x
    for idx, seg in ipairs(segments) do
        set_color(cr, "custom", seg.color)
        set_font(cr, font_name, font_size, font_bold, font_italic)
        local ext = cairo_text_extents_t:create()
        cairo_text_extents(cr, seg.txt, ext)
        if cursor + ext.width <= x + max_width then
            draw_emoji_text(cr, seg.txt, font_name, font_bold, font_size, cursor, y, font_italic)
            cursor = cursor + ext.x_advance
        else
            -- Trzeba przyciąć segment z wielokropkiem
            local sub = seg.txt
            local found = false
            for i = 1, utf8_len(seg.txt) do
                local chunk = utf8_sub(seg.txt, 1, i) .. "..."
                cairo_text_extents(cr, chunk, ext)
                if cursor + ext.width > x + max_width then
                    sub = utf8_sub(seg.txt, 1, i-1)
                    found = true
                    break
                end
            end
            draw_emoji_text(cr, sub .. "...", font_name, font_bold, font_size, cursor, y, font_italic)
            cursor = cursor + ext.x_advance
            break
        end
    end
    return cursor
end

local function draw_meta_segments_scrolling(cr, segments, font_name, font_bold, font_size, font_italic, x, y, max_width, scroll_offset)
    local cursor = x - (scroll_offset or 0)
    for idx, seg in ipairs(segments) do
        set_color(cr, "custom", seg.color)
        set_font(cr, font_name, font_size, font_bold, font_italic)
        draw_emoji_text(cr, seg.txt, font_name, font_bold, font_size, cursor, y, font_italic)
        local ext = cairo_text_extents_t:create()
        cairo_text_extents(cr, seg.txt, ext)
        cursor = cursor + ext.x_advance
        if cursor > x + max_width then break end
    end
end

-- [PATCH] podpis segmentów do cache szerokości meta
local function segments_signature(segments)
    local t = {}
    for _, seg in ipairs(segments) do
        t[#t+1] = seg.txt or ""
    end
    return table.concat(t, "\31")
end
-- [/PATCH]

local function draw_meta_line_rich(cr, mail, x, y)
    local meta_id = "meta|" .. (mail.uid or get_mail_id(mail))
    local now = now_time()
    local state = meta_scroll_states[meta_id]
    if not state or state.last_mail_id ~= meta_id then
        meta_scroll_states[meta_id] = {start_time=now, phase="start", rep=0, last_mail_id=meta_id}
        state = meta_scroll_states[meta_id]
    end

    local font_name = META_LINE_FONT_NAME
    local font_bold = META_LINE_FONT_BOLD
    local font_size = META_LINE_FONT_SIZE
    local font_italic = META_LINE_FONT_ITALIC

    local segments = build_meta_line_segments(mail)
    if #segments == 0 then return end

    -- [PATCH] cache szerokości meta-linii
    local sig = segments_signature(segments)
    local key = table.concat({sig, font_name, font_size, font_bold and "b" or "n", font_italic and "i" or "n"}, "|")
    local total_width = meta_width_cache[key]
    if not total_width then
        total_width = measure_meta_line_width(cr, segments, font_name, font_bold, font_size, font_italic)
        meta_width_cache[key] = total_width
    end
    -- [/PATCH]

    if total_width <= META_LINE_MAX_WIDTH or not (META_LINE_SCROLL_ENABLE and is_new_mail(mail)) then
    draw_meta_segments_trimmed(cr, segments, font_name, font_bold, font_size, font_italic, x, y, META_LINE_MAX_WIDTH)
    return
end

    -- przewijanie
    local scroll_extra = META_LINE_SCROLL_EXTRA or (36 * GLOBAL_SCALE_FACTOR)
    local scroll_len = total_width - META_LINE_MAX_WIDTH + scroll_extra
    if scroll_len < 1 then scroll_len = 1 end
    local delay_start  = META_LINE_SCROLL_DELAY or 0
    local pause_end    = 1.0
    local scroll_speed = META_LINE_SCROLL_SPEED or (72 * GLOBAL_SCALE_FACTOR)
    local scroll_repeat = META_LINE_SCROLL_REPEAT or 2
    local scroll_time  = math.max(scroll_len / scroll_speed, 0.5)
    local elapsed = now - state.start_time
    local phase = state.phase
    local ease_func = META_LINE_SCROLL_EASE or "linear"

    if phase == "start" then
        if elapsed < delay_start then
            draw_meta_segments_trimmed(cr, segments, font_name, font_bold, font_size, font_italic, x, y, META_LINE_MAX_WIDTH)
        else
            state.phase = "scroll"
            state.start_time = now
        end

    elseif phase == "scroll" then
        local t = math.min(1, elapsed / scroll_time)
        local ease_t = (ease_func == "easeOut") and ease_out(t) or t
        local offset = ease_t * scroll_len

        cairo_save(cr)
        cairo_rectangle(cr, x, y - font_size, META_LINE_MAX_WIDTH, font_size + (12 * GLOBAL_SCALE_FACTOR))
        cairo_clip(cr)
        draw_meta_segments_scrolling(cr, segments, font_name, font_bold, font_size, font_italic, x, y, META_LINE_MAX_WIDTH, offset)
        cairo_restore(cr)

        if t >= 1 then
            state.phase = "pause_end"
            state.start_time = now
        end

    elseif phase == "pause_end" then
        if elapsed < pause_end then
            cairo_save(cr)
            cairo_rectangle(cr, x, y - font_size, META_LINE_MAX_WIDTH, font_size + (12 * GLOBAL_SCALE_FACTOR))
            cairo_clip(cr)
            draw_meta_segments_scrolling(cr, segments, font_name, font_bold, font_size, font_italic, x, y, META_LINE_MAX_WIDTH, scroll_len)
            cairo_restore(cr)
        else
            state.rep = state.rep + 1
            if state.rep < scroll_repeat then
                state.phase = "start"
                state.start_time = now
            else
                state.phase = "done"
            end
        end

    elseif phase == "done" then
        draw_meta_segments_trimmed(cr, segments, font_name, font_bold, font_size, font_italic, x, y, META_LINE_MAX_WIDTH)
    end
end

-- ========== KONIEC NOWEJ META-LINII ==========

local function draw_custom_user_text(cr)
    if not CUSTOM_TEXT_ENABLE or not CUSTOM_TEXT_VALUE or CUSTOM_TEXT_VALUE == "" then return end
    set_color(cr, CUSTOM_TEXT_COLOR_TYPE, CUSTOM_TEXT_COLOR_CUSTOM)
    set_font(cr, CUSTOM_TEXT_FONT, CUSTOM_TEXT_SIZE, CUSTOM_TEXT_BOLD, CUSTOM_TEXT_ITALIC)
    draw_emoji_text(cr, CUSTOM_TEXT_VALUE, CUSTOM_TEXT_FONT, CUSTOM_TEXT_BOLD, CUSTOM_TEXT_SIZE, CUSTOM_TEXT_POS.x, CUSTOM_TEXT_POS.y, CUSTOM_TEXT_ITALIC)
end

local function draw_separator(cr)
    if not SEPARATOR_ENABLE then return end
    local x1 = SEPARATOR_X
    local y1 = SEPARATOR_Y
    local x2 = SEPARATOR_X + SEPARATOR_LENGTH
    local y2 = SEPARATOR_Y

    set_color(cr, SEPARATOR_COLOR_TYPE, SEPARATOR_COLOR_CUSTOM)
    cairo_set_line_width(cr, SEPARATOR_WIDTH or (1.5 * GLOBAL_SCALE_FACTOR))
    cairo_move_to(cr, x1, y1)
    cairo_line_to(cr, x2, y2)
    cairo_stroke(cr)
end

local function get_mail_block_height(mail)
    local h = FROM_FONT_SIZE
    if SHOW_MAIL_PREVIEW and mail and mail.preview then
        h = h + MAIL_PREVIEW_SPACING + PREVIEW_FONT_SIZE
    end
    if META_LINE_ENABLE then
        h = h + META_LINE_SPACING + META_LINE_FONT_SIZE
    end
    h = h + MAIL_ROW_SPACING
    return h
end

-- === SCROLL 1:1 (offset z pliku + timeout po mtime) ===
local function read_mail_scroll_offset()
    local f = io.open(MAIL_SCROLL_FILE, "r")
    if f then
        local value = tonumber((f:read("*a") or "0"):match("%-?%d+")) or 0
        f:close()
        return value
    end
    return 0
end

local function write_mail_scroll_offset(offset)
    local f = io.open(MAIL_SCROLL_FILE, "w")
    if f then f:write(tostring(offset)); f:close() end
end

local function get_mail_scroll_mtime()
    local p = io.popen("stat -c %Y " .. MAIL_SCROLL_FILE .. " 2>/dev/null")
    local mtime = p and tonumber(p:read("*a"))
    if p then p:close() end
    return mtime or 0
end

-- Zwraca: mails_to_draw, offset, max_offset
local function apply_mail_scroll(filtered_mails, MAX_MAILS, MAILS_DIRECTION)
    local N = #filtered_mails
    local max_visible = math.max(0, MAX_MAILS or 0)
    local max_offset  = math.max(N - max_visible, 0)

    -- offset + timeout → 0
    local offset = read_mail_scroll_offset()
    local last_mtime = get_mail_scroll_mtime()
    local now = os.time()
    if offset ~= 0 and (now - last_mtime > (SCROLL_TIMEOUT or 3)) then
        offset = 0
        write_mail_scroll_offset(0)
    end

    -- clamp
    if offset < 0 then offset = 0 end
    if offset > max_offset then
        offset = max_offset
        write_mail_scroll_offset(offset)
    end

    -- slice
    local first = math.max(1, 1 + offset)
    local last  = math.min(N, first + max_visible - 1)
    local out = {}
    for i = first, last do out[#out+1] = filtered_mails[i] end

    return out, offset, max_offset
end

local function _conky_draw_mail_indicator_impl()
    if conky_window == nil then return end
    set_layout_by_mode()


-- POBIERANIE DANYCH
local data = fetch_mails_from_cache()
local unread        = tonumber(data.unread) or 0
local all           = tonumber(data.all) or unread
local unread_cache = tonumber(data.unread_cache) or 0
local mails         = data.mails or {}

local badge_count
if BADGE_SOURCE == "all" then
    badge_count = all
elseif BADGE_SOURCE == "unread_cache" then
    badge_count = unread_cache
else -- domyślnie "unread"
    badge_count = unread
end

    -- Zbuduj last_good_mails (używane do rysowania)
    last_good_mails = {}
    for i, mail in ipairs(mails) do
        local from
        if SHOW_SENDER_EMAIL then
            from = safe_str(mail.from, "(brak nadawcy)")
        else
            from = safe_str(mail.from_name, safe_str(mail.from, "(brak nadawcy)"))
        end
        local subject = safe_str(mail.subject, "(brak tematu)")
        local preview = safe_str(mail.preview, "(brak podglądu)")
        table.insert(last_good_mails, {
            from=from,
            subject=subject,
            preview=preview,
            has_attachment=mail.has_attachment,
            from_raw=mail.from,
            from_name=mail.from_name,
            meta=mail.meta,
            uid=mail.uid,
            account_name = mail.account_name,
            -- =================================================================
            -- KRYTYCZNA ZMIANA: Przekazanie danych o kolorze do tabeli roboczej
            -- =================================================================
            color = mail.color
        })
    end


    -- Czyść stany scrollujące temat/preview po zmianach listy
    do
        local valid_ids = {}
        for i, mail in ipairs(last_good_mails) do
            valid_ids["subject|" .. get_mail_id(mail) .. "|" .. (mail.subject or "")] = true
        local pid = mail.uid or get_mail_id(mail)
        valid_ids["preview|" .. get_mail_id(mail) .. "|" .. join_preview_lines(mail.preview, MAIL_PREVIEW_LINES)] = true

        end
        for key, tbl in pairs(scroll_states) do
            for k in pairs(tbl) do
                if not valid_ids[k] then tbl[k] = nil end
            end
        end
    end

    -- Czyść stany scrollujące meta-linię po zmianach listy
    do
        local valid_meta_ids = {}
        for i, mail in ipairs(last_good_mails) do
            valid_meta_ids["meta|" .. (mail.uid or get_mail_id(mail))] = true
        end
        for k in pairs(meta_scroll_states) do
            if not valid_meta_ids[k] then meta_scroll_states[k] = nil end
        end
    end

    -- DŹWIĘKI (nowy/znikający mail)
    if NEW_MAIL_SOUND_ENABLE and last_mail_json_ok and previous_unread_count ~= nil and unread > previous_unread_count then
        if file_exists(NEW_MAIL_SOUND) then
            os.execute('paplay "' .. NEW_MAIL_SOUND .. '" &')
        else
            print("BŁĄD: Nie znaleziono pliku dźwięku: " .. NEW_MAIL_SOUND)
        end
    end
    if MAIL_DISAPPEAR_SOUND_ENABLE and last_mail_json_ok and previous_unread_count ~= nil and unread < previous_unread_count then
        if file_exists(MAIL_DISAPPEAR_SOUND) then
            os.execute('paplay "' .. MAIL_DISAPPEAR_SOUND .. '" &')
        else
            print("BŁĄD: Nie znaleziono pliku dźwięku: " .. MAIL_DISAPPEAR_SOUND)
        end
    end
    previous_unread_count = unread

    --------------------------------------------------------------------
-- SCROLL: mtime + timeout → 0 (nowa wersja)
--------------------------------------------------------------------
local visible, mail_scroll_offset, max_offset =
    apply_mail_scroll(last_good_mails, MAX_MAILS, MAILS_DIRECTION)
--------------------------------------------------------------------


    -- Cairo surface
    local cs = cairo_xlib_surface_create(conky_window.display,
                                         conky_window.drawable,
                                         conky_window.visual,
                                         conky_window.width,
                                         conky_window.height)
    local cr = cairo_create(cs)

    -- Nagłówek + separator
    draw_custom_user_text(cr)
    draw_separator(cr)

    -- Koperta
    if SHOW_ENVELOPE_ICON then
        draw_png_rotated(cr, ENVELOPE_POS.x, ENVELOPE_POS.y, ENVELOPE_SIZE.w, ENVELOPE_SIZE.h, ENVELOPE_IMAGE, ENVELOPE_IMAGE_ANGLE, ENVELOPE_MIRROR)
    end

    -- Badge
    if SHOW_BADGE and badge_count > 0 then
        local badge_x = ENVELOPE_POS.x + (BADGE_POS.dx or (ENVELOPE_SIZE.w - BADGE_RADIUS + (3 * GLOBAL_SCALE_FACTOR)))
        local badge_y = ENVELOPE_POS.y + (BADGE_POS.dy or (-BADGE_RADIUS + (24 * GLOBAL_SCALE_FACTOR)))
        cairo_arc(cr, badge_x, badge_y, BADGE_RADIUS, 0, 2*math.pi)
        set_color(cr, BADGE_COLOR_TYPE, BADGE_COLOR_CUSTOM)
        cairo_fill_preserve(cr)
        set_color(cr, BADGE_BORDER_COLOR_TYPE, BADGE_BORDER_COLOR_CUSTOM)
        cairo_set_line_width(cr, 3.3 * GLOBAL_SCALE_FACTOR) -- Skalowana szerokość obwódki badge
        cairo_stroke(cr)
        set_color(cr, BADGE_TEXT_COLOR_TYPE, BADGE_TEXT_COLOR_CUSTOM)
        set_font(cr, FROM_FONT_NAME, FROM_FONT_SIZE + (4.5 * GLOBAL_SCALE_FACTOR), true, FROM_FONT_ITALIC) -- Skalowany rozmiar czcionki badge
        local txt = tostring(badge_count)
        local ext = cairo_text_extents_t:create()
        cairo_text_extents(cr, txt, ext)
        cairo_move_to(cr, badge_x - ext.width/2 - ext.x_bearing, badge_y + ext.height/2)
        cairo_show_text(cr, txt)
    end


    local num_mails = #visible
    local text_x = MAILS_POS.x

    -- Wylicz pozycje wszystkich maili na ekranie (dla wybranego wycinka)
    local mail_positions = {}

    if MAILS_DIRECTION == "down" then
        local y = MAILS_POS.y
        for i = 1, num_mails do
            mail_positions[i] = y
            y = y + get_mail_block_height(visible[i] or {})
        end
    else
        local y = conky_window.height - MAILS_POS.y
        for i = num_mails, 1, -1 do
            y = y - get_mail_block_height(visible[i] or {})
            mail_positions[i] = y
        end
    end

    -- Rysowanie każdej pozycji (tylko z 'visible')
    for i = 1, num_mails do
        local mail = visible[i] or {}
        local y_offset = mail_positions[i]

        -- Mleczna poświata (opcjonalnie)
        if PER_MAIL_MILK_FILL_ENABLE or PER_MAIL_MILK_BORDER_ENABLE then
            local milk_x = text_x + (PER_MAIL_MILK_MARGIN_X or 0)
            local milk_y = y_offset + (PER_MAIL_MILK_MARGIN_Y or 0)
            local milk_w = PER_MAIL_MILK_WIDTH or (1065 * GLOBAL_SCALE_FACTOR)
            local milk_h = PER_MAIL_MILK_HEIGHT or (82.5 * GLOBAL_SCALE_FACTOR)

            -- Zabezpieczenie promienia
            local max_radius = math.min(milk_w, milk_h) / 2
            local milk_radius = PER_MAIL_MILK_RADIUS
            if milk_radius < 0 then milk_radius = 0 end
            if milk_radius > max_radius then milk_radius = max_radius end
            if PER_MAIL_MILK_RADIUS < 0 or PER_MAIL_MILK_RADIUS > max_radius then
                print(string.format("[UWAGA] PER_MAIL_MILK_RADIUS=%s spoza zakresu! Poprawiono do %s", tostring(PER_MAIL_MILK_RADIUS), tostring(milk_radius)))
            end

            draw_per_mail_milk(
                cr,
                milk_x, milk_y,
                milk_w, milk_h,
                milk_radius,
                PER_MAIL_MILK_FILL_ENABLE,
                PER_MAIL_MILK_FILL_COLOR,
                PER_MAIL_MILK_FILL_ALPHA,
                PER_MAIL_MILK_BORDER_ENABLE,
                PER_MAIL_MILK_BORDER_COLOR,
                PER_MAIL_MILK_BORDER_ALPHA,
                PER_MAIL_MILK_BORDER_WIDTH
            )
        end

        -- Nadawca
        set_font(cr, FROM_FONT_NAME, FROM_FONT_SIZE, FROM_FONT_BOLD, FROM_FONT_ITALIC)
        local from_prefix = ""
        if mail.account_name and mail.account_name ~= "" then
            from_prefix = "[" .. mail.account_name .. "] "
        end
        local from_txt = from_prefix .. (mail.from or ""):gsub(":*$", "") .. ":"
        local from_end = draw_from_scrolling(cr, mail, from_txt, text_x, y_offset)

        -- Ikony załącznika
        if mail.has_attachment then
            if ATTACHMENT_ICON_ENABLE then
                local icon_x = text_x + ATTACHMENT_ICON_OFFSET.dx
                local icon_y = y_offset + ATTACHMENT_ICON_OFFSET.dy
                draw_png_rotated(cr, icon_x, icon_y, ATTACHMENT_ICON_SIZE.w, ATTACHMENT_ICON_SIZE.h, ATTACHMENT_ICON_IMAGE, ATTACHMENT_ICON_ANGLE, ATTACHMENT_ICON_MIRROR)
            end
            if ATTACHMENT_DOT_ENABLE then
                local dot_x = text_x + ATTACHMENT_DOT_OFFSET.dx
                local dot_y = y_offset + ATTACHMENT_DOT_OFFSET.dy + FROM_FONT_SIZE/2
                cairo_arc(cr, dot_x, dot_y, ATTACHMENT_DOT_RADIUS, 0, 2*math.pi)
                set_color(cr, ATTACHMENT_DOT_COLOR_TYPE, ATTACHMENT_DOT_COLOR_CUSTOM)
                cairo_fill(cr)
            end
        end

        -- Temat
        set_color(cr, SUBJECT_COLOR_TYPE, SUBJECT_COLOR_CUSTOM)
        set_font(cr, SUBJECT_FONT_NAME, SUBJECT_FONT_SIZE, SUBJECT_FONT_BOLD, SUBJECT_FONT_ITALIC)
        local subject_txt = mail.subject or ""
        local subject_x = from_end + FROM_TO_SUBJECT_GAP
        draw_scrolling_text(
            cr, "subject", mail, subject_txt, subject_x, y_offset, SUBJECT_MAX_WIDTH - (subject_x - text_x) - (18 * GLOBAL_SCALE_FACTOR),
            SUBJECT_FONT_NAME, SUBJECT_FONT_SIZE, SUBJECT_FONT_BOLD, SUBJECT_FONT_ITALIC,
            {
                scroll_enable = SUBJECT_SCROLL_ENABLE and is_new_mail(mail),
                scroll_speed  = SUBJECT_SCROLL_SPEED,
                scroll_repeat = SUBJECT_SCROLL_REPEAT,
                scroll_delay  = SUBJECT_SCROLL_DELAY,
                scroll_ease   = SUBJECT_SCROLL_EASE,
                scroll_extra  = SUBJECT_SCROLL_EXTRA,
            }
        )

-- Podgląd treści (preview)
local preview_y = y_offset + FROM_FONT_SIZE + MAIL_PREVIEW_SPACING
if SHOW_MAIL_PREVIEW and mail.preview then
    set_color(cr, PREVIEW_COLOR_TYPE, PREVIEW_COLOR_CUSTOM)
    set_font(cr, PREVIEW_FONT_NAME, PREVIEW_FONT_SIZE, PREVIEW_FONT_BOLD, PREVIEW_FONT_ITALIC)
    local preview_line = join_preview_lines(mail.preview, MAIL_PREVIEW_LINES)
    local preview_cursor = PREVIEW_INDENT and (text_x + (27 * GLOBAL_SCALE_FACTOR)) or text_x
    draw_scrolling_text(
        cr, "preview", mail, preview_line, preview_cursor, preview_y,
        PREVIEW_MAX_WIDTH - (18 * GLOBAL_SCALE_FACTOR),
        PREVIEW_FONT_NAME, PREVIEW_FONT_SIZE, PREVIEW_FONT_BOLD, PREVIEW_FONT_ITALIC,
        {
            scroll_enable = PREVIEW_SCROLL_ENABLE and is_new_mail(mail),
            scroll_speed  = PREVIEW_SCROLL_SPEED,
            scroll_repeat = PREVIEW_SCROLL_REPEAT,
            scroll_delay  = PREVIEW_SCROLL_DELAY,
            scroll_ease   = PREVIEW_SCROLL_EASE,
            scroll_extra  = PREVIEW_SCROLL_EXTRA,
        }
    )
end

        -- Meta-linia (3. linia pod mailem)
        if META_LINE_ENABLE then
            local meta_y
            if SHOW_MAIL_PREVIEW and mail.preview then
                meta_y = preview_y + PREVIEW_FONT_SIZE + META_LINE_SPACING
            else
                meta_y = y_offset + FROM_FONT_SIZE + META_LINE_SPACING
            end
            draw_meta_line_rich(cr, mail, text_x, meta_y)
        end
    end

    cairo_destroy(cr)
    cairo_surface_destroy(cs)
end
function conky_draw_mail_indicator()
    local ok, err = xpcall(_conky_draw_mail_indicator_impl, function(e)
        return debug.traceback(e, 2)
    end)
    if not ok then
        print("[conky-mail:err] " .. tostring(err))
    end
end
